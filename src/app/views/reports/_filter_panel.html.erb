<style>
.filter-rows {
  display: flex !important;
  flex-direction: column !important;
  gap: 20px !important;
}

.filter-row {
  display: grid !important;
  grid-template-columns: repeat(4, 1fr) !important;
  gap: 15px !important;
}

.filter-field {
  display: flex !important;
  flex-direction: column !important;
}

@media (max-width: 768px) {
  .filter-row {
    grid-template-columns: 1fr !important;
    gap: 15px !important;
  }
}

.filter-panel {
  background-color: #f8f9fa;
  border: 1px solid #dee2e6;
  border-radius: 5px;
  padding: 20px;
  margin: 20px 0;
  background-color: white;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.filter-panel h3 {
  margin-top: 0;
  color: #495057;
}

.filter-actions {
  margin-top: 20px;
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
}

.filter-actions button {
  padding: 6px 12px;
  border: 1px solid #ccc;
  background-color: #f8f8f8;
  color: #333;
  border-radius: 3px;
  cursor: pointer;
  font-size: 11px;
  margin-right: 5px;
  vertical-align: middle;
  display: inline-flex;
  align-items: center;
  justify-content: center;
}

.filter-actions button:hover {
  background-color: #e8e8e8;
  border-color: #999;
}

.filter-actions button:active {
  background-color: #ddd;
}

.filter-select {
  width: 100%;
  padding: 8px;
  border: 1px solid #ced4da;
  border-radius: 4px;
}

.filter-multi-select {
  min-height: 80px;
  height: auto;
}
</style>

<div id="redmine-issue-summary-filter-panel" class="filter-panel">
  <h3>ğŸ” ãƒã‚±ãƒƒãƒˆãƒ•ã‚£ãƒ«ã‚¿ãƒ¼</h3>
  
  <form method="get" id="redmine-issue-filter-form">
    <div class="filter-container">
      <div class="filter-rows">
        <div class="filter-row">
          <div class="filter-field">
            <label for="filter_created_on_from">ä½œæˆæ—¥ï¼ˆé–‹å§‹ï¼‰</label>
            <input type="date" id="filter_created_on_from" name="filter[created_on_from]" 
                   value="<%= filter_params && filter_params[:created_on_from] ? filter_params[:created_on_from] : '' %>" 
                   class="filter-select">
          </div>
          
          <div class="filter-field">
            <label for="filter_created_on_to">ä½œæˆæ—¥ï¼ˆçµ‚äº†ï¼‰</label>
            <input type="date" id="filter_created_on_to" name="filter[created_on_to]" 
                   value="<%= filter_params && filter_params[:created_on_to] ? filter_params[:created_on_to] : '' %>" 
                   class="filter-select">
          </div>
          
          <div class="filter-field">
            <label for="filter_updated_on_from">æ›´æ–°æ—¥ï¼ˆé–‹å§‹ï¼‰</label>
            <input type="date" id="filter_updated_on_from" name="filter[updated_on_from]" 
                   value="<%= filter_params && filter_params[:updated_on_from] ? filter_params[:updated_on_from] : '' %>" 
                   class="filter-select">
          </div>
          
          <div class="filter-field">
            <label for="filter_updated_on_to">æ›´æ–°æ—¥ï¼ˆçµ‚äº†ï¼‰</label>
            <input type="date" id="filter_updated_on_to" name="filter[updated_on_to]" 
                   value="<%= filter_params && filter_params[:updated_on_to] ? filter_params[:updated_on_to] : '' %>" 
                   class="filter-select">
          </div>
        </div>
        
        <div class="filter-row">
          <div class="filter-field">
            <label for="filter_status_id">ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹</label>
            <select id="filter_status_id" name="filter[status_id][]" multiple class="filter-select filter-multi-select">
              <option value="">ã™ã¹ã¦</option>
              <% project.rolled_up_statuses.sorted.each do |status| %>
                <option value="<%= status.id %>" <%= 'selected' if filter_params && filter_params[:status_id] && filter_params[:status_id].include?(status.id.to_s) %>>
                  <%= status.name %>
                </option>
              <% end %>
            </select>
          </div>
          
          <div class="filter-field">
            <label for="filter_priority_id">å„ªå…ˆåº¦</label>
            <select id="filter_priority_id" name="filter[priority_id][]" multiple class="filter-select filter-multi-select">
              <option value="">ã™ã¹ã¦</option>
              <% IssuePriority.active.each do |priority| %>
                <option value="<%= priority.id %>" <%= 'selected' if filter_params && filter_params[:priority_id] && filter_params[:priority_id].include?(priority.id.to_s) %>>
                  <%= priority.name %>
                </option>
              <% end %>
            </select>
          </div>
          
          <div class="filter-field">
            <label for="filter_fixed_version_id">ãƒãƒ¼ã‚¸ãƒ§ãƒ³</label>
            <select id="filter_fixed_version_id" name="filter[fixed_version_id][]" multiple class="filter-select filter-multi-select">
              <option value="">ã™ã¹ã¦</option>
              <% project.shared_versions.each do |version| %>
                <option value="<%= version.id %>" <%= 'selected' if filter_params && filter_params[:fixed_version_id] && filter_params[:fixed_version_id].include?(version.id.to_s) %>>
                  <%= version.name %>
                </option>
              <% end %>
            </select>
          </div>
          
          <div class="filter-field">
            <label for="filter_assigned_to_id">æ‹…å½“è€…</label>
            <select id="filter_assigned_to_id" name="filter[assigned_to_id][]" multiple class="filter-select filter-multi-select">
              <option value="">ã™ã¹ã¦</option>
              <% project.assignable_users.each do |user| %>
                <option value="<%= user.id %>" <%= 'selected' if filter_params && filter_params[:assigned_to_id] && filter_params[:assigned_to_id].include?(user.id.to_s) %>>
                  <%= user.name %>
                </option>
              <% end %>
            </select>
          </div>
        </div>
        
        <div class="filter-row">
          <div class="filter-field">
            <label for="filter_tracker_id">ãƒˆãƒ©ãƒƒã‚«ãƒ¼</label>
            <select id="filter_tracker_id" name="filter[tracker_id][]" multiple class="filter-select filter-multi-select">
              <option value="">ã™ã¹ã¦</option>
              <% project.rolled_up_trackers.each do |tracker| %>
                <option value="<%= tracker.id %>" <%= 'selected' if filter_params && filter_params[:tracker_id] && filter_params[:tracker_id].include?(tracker.id.to_s) %>>
                  <%= tracker.name %>
                </option>
              <% end %>
            </select>
          </div>
          
          <div class="filter-field">
            <label for="filter_category_id">ã‚«ãƒ†ã‚´ãƒª</label>
            <select id="filter_category_id" name="filter[category_id][]" multiple class="filter-select filter-multi-select">
              <option value="">ã™ã¹ã¦</option>
              <% project.issue_categories.each do |category| %>
                <% should_select = filter_params && filter_params[:category_id] && filter_params[:category_id].include?(category.id.to_s) %>
                <option value="<%= category.id %>" <%= 'selected' if should_select %>>
                  <%= category.name %>
                </option>
              <% end %>
            </select>
          </div>
        </div>
      </div>
      
      <div class="filter-actions">
        <button type="button" onclick="applyFilter()">ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼é©ç”¨</button>
        <button type="button" onclick="clearFilter()">ã‚¯ãƒªã‚¢</button>
        <button type="button" onclick="saveFilter()">ä¿å­˜</button>
        <button type="button" onclick="loadFilter()">èª­ã¿è¾¼ã¿</button>
      </div>
    </div>
  </form>
</div>

<script>
function applyFilter() {
  const form = document.getElementById('redmine-issue-filter-form');
  if (!form) {
    return;
  }
  
  // ãƒ•ã‚©ãƒ¼ãƒ ã®actionå±æ€§ã‚’è¨­å®š
  const currentPath = window.location.pathname;
  form.action = currentPath;
  
  const params = new URLSearchParams();
  
  // æ—¥ä»˜ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’è¿½åŠ 
  const createdOnFrom = document.getElementById('filter_created_on_from');
  const createdOnTo = document.getElementById('filter_created_on_to');
  const updatedOnFrom = document.getElementById('filter_updated_on_from');
  const updatedOnTo = document.getElementById('filter_updated_on_to');
  
  if (createdOnFrom && createdOnFrom.value) {
    params.append('filter[created_on_from]', createdOnFrom.value);
  }
  
  if (createdOnTo && createdOnTo.value) {
    params.append('filter[created_on_to]', createdOnTo.value);
  }
  
  if (updatedOnFrom && updatedOnFrom.value) {
    params.append('filter[updated_on_from]', updatedOnFrom.value);
  }
  
  if (updatedOnTo && updatedOnTo.value) {
    params.append('filter[updated_on_to]', updatedOnTo.value);
  }
  
  // ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æ§‹ç¯‰
  const selects = document.querySelectorAll('.filter-multi-select');
  selects.forEach(select => {
    const fieldName = select.name;
    const selectedValues = Array.from(select.selectedOptions).map(option => option.value);
    
    // ã€Œã™ã¹ã¦ã€ãŒé¸æŠã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
    const hasAllSelected = selectedValues.includes('');
    const hasOtherValues = selectedValues.some(v => v !== '');
    
    if (hasAllSelected && hasOtherValues) {
      // ã€Œã™ã¹ã¦ã€ã¨ä»–ã®å€¤ãŒä¸¡æ–¹é¸æŠã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€ã€Œã™ã¹ã¦ã€ã‚’å„ªå…ˆ
    } else if (hasOtherValues) {
      // ä»–ã®å€¤ãŒé¸æŠã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€ãã‚Œã‚‰ã®å€¤ã®ã¿ã‚’é€ä¿¡
      selectedValues.filter(v => v !== '').forEach(value => {
        params.append(fieldName, value);
      });
    }
  });
  
  const url = currentPath + '?' + params.toString();
  window.location.href = url;
}

function clearFilter() {
  // ã™ã¹ã¦ã®é¸æŠã‚’ã€Œã™ã¹ã¦ã€ã«ãƒªã‚»ãƒƒãƒˆ
  const selects = document.querySelectorAll('.filter-multi-select');
  selects.forEach(select => {
    // ã™ã¹ã¦ã®é¸æŠã‚’è§£é™¤
    Array.from(select.options).forEach(option => {
      option.selected = false;
    });
    // ã€Œã™ã¹ã¦ã€ã‚’é¸æŠ
    const allOption = select.querySelector('option[value=""]');
    if (allOption) {
      allOption.selected = true;
    }
  });
  
  // æ—¥ä»˜ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‚‚ã‚¯ãƒªã‚¢
  const createdOnFrom = document.getElementById('filter_created_on_from');
  const createdOnTo = document.getElementById('filter_created_on_to');
  const updatedOnFrom = document.getElementById('filter_updated_on_from');
  const updatedOnTo = document.getElementById('filter_updated_on_to');
  if (createdOnFrom) createdOnFrom.value = '';
  if (createdOnTo) createdOnTo.value = '';
  if (updatedOnFrom) updatedOnFrom.value = '';
  if (updatedOnTo) updatedOnTo.value = '';
  
  applyFilter();
}

function saveFilter() {
  const filterData = {};
  const selects = document.querySelectorAll('.filter-multi-select');
  
  selects.forEach(select => {
    const fieldName = select.name.replace('filter[', '').replace('][]', '');
    const selectedValues = Array.from(select.selectedOptions).map(option => option.value).filter(v => v !== '');
    if (selectedValues.length > 0) {
      filterData[fieldName] = selectedValues;
    }
  });
  
  const projectId = window.location.pathname.split('/')[2];
  localStorage.setItem('redmine_issue_filter_' + projectId, JSON.stringify(filterData));
  alert('ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼è¨­å®šã‚’ä¿å­˜ã—ã¾ã—ãŸ');
}

function loadFilter() {
  const projectId = window.location.pathname.split('/')[2];
  const savedData = localStorage.getItem('redmine_issue_filter_' + projectId);
  if (!savedData) {
    alert('ä¿å­˜ã•ã‚ŒãŸãƒ•ã‚£ãƒ«ã‚¿ãƒ¼è¨­å®šãŒã‚ã‚Šã¾ã›ã‚“');
    return;
  }
  
  try {
    const filterData = JSON.parse(savedData);
    const selects = document.querySelectorAll('.filter-multi-select');
    
    selects.forEach(select => {
      const fieldName = select.name.replace('filter[', '').replace('][]', '');
      if (filterData[fieldName]) {
        Array.from(select.options).forEach(option => {
          option.selected = filterData[fieldName].includes(option.value);
        });
      } else {
        // ä¿å­˜ã•ã‚Œã¦ã„ãªã„ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã¯ã€Œã™ã¹ã¦ã€ã‚’é¸æŠ
        select.selectedIndex = 0;
      }
    });
    
    alert('ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼è¨­å®šã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸ');
  } catch (e) {
    alert('ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼è¨­å®šã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ');
  }
}

// ã‚³ãƒ³ãƒœãƒœãƒƒã‚¯ã‚¹ã®é¸æŠçŠ¶æ…‹ã‚’ç®¡ç†
function setupSelectBehavior() {
  const selects = document.querySelectorAll('.filter-multi-select');
  selects.forEach(select => {
    // åˆæœŸçŠ¶æ…‹ã‚’ã€Œã™ã¹ã¦ã€ã«è¨­å®š
    const allOption = select.querySelector('option[value=""]');
    if (allOption && !select.querySelector('option:checked')) {
      allOption.selected = true;
    }
    
    select.addEventListener('change', function() {
      const selectedValues = Array.from(this.selectedOptions).map(option => option.value);
      const hasAllSelected = selectedValues.includes('');
      const hasOtherValues = selectedValues.some(v => v !== '');
      
      if (hasAllSelected && hasOtherValues) {
        // ã€Œã™ã¹ã¦ã€ã¨ä»–ã®å€¤ãŒä¸¡æ–¹é¸æŠã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€ã€Œã™ã¹ã¦ã€ã‚’è§£é™¤
        const allOption = this.querySelector('option[value=""]');
        if (allOption) {
          allOption.selected = false;
        }
      } else if (!hasAllSelected && !hasOtherValues) {
        // ä½•ã‚‚é¸æŠã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã€ã€Œã™ã¹ã¦ã€ã‚’é¸æŠ
        const allOption = this.querySelector('option[value=""]');
        if (allOption) {
          allOption.selected = true;
        }
      }
    });
  });
}

// URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‹ã‚‰é¸æŠçŠ¶æ…‹ã‚’å¾©å…ƒ
function restoreFilterFromURL() {
  const urlParams = new URLSearchParams(window.location.search);
  const filterParams = {};
  
  // filter[field_name][] å½¢å¼ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’å–å¾—
  urlParams.forEach((value, key) => {
    // filter[status_id][] ã®ã‚ˆã†ãªå½¢å¼ã‚’å‡¦ç†
    const match = key.match(/filter\[(.+)\]/);
    if (match) {
      const fieldName = match[1];
      if (!filterParams[fieldName]) {
        filterParams[fieldName] = [];
      }
      filterParams[fieldName].push(value);
    }
  });
  
  // å„selectã‚’æ›´æ–°
  const selects = document.querySelectorAll('.filter-multi-select');
  selects.forEach(select => {
    // select.name ã¯ "filter[priority_id][]" ã®ã‚ˆã†ãªå½¢å¼
    const match = select.name.match(/filter\[(.+)\]\[\]/);
    if (match) {
      const fieldName = match[1];
      
      if (filterParams[fieldName]) {
        Array.from(select.options).forEach(option => {
          option.selected = filterParams[fieldName].includes(option.value);
        });
      } else {
        // ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ã€ã€Œã™ã¹ã¦ã€ã‚’é¸æŠ
        select.selectedIndex = 0;
      }
    }
  });
}

// ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ãƒ‘ãƒãƒ«ã‚’ãƒ¬ãƒãƒ¼ãƒˆã®ä¸‹ã«ç§»å‹•
document.addEventListener('DOMContentLoaded', function() {
  // URLãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‹ã‚‰é¸æŠçŠ¶æ…‹ã‚’å¾©å…ƒï¼ˆã‚µãƒ¼ãƒãƒ¼ã‚µã‚¤ãƒ‰ã§é¸æŠã•ã‚Œã¦ã„ãªã„å ´åˆã®ã¿ï¼‰
  // Rubyã®ERBã§æ—¢ã«é¸æŠã•ã‚Œã¦ã„ã‚‹å ´åˆã¯ã€JavaScriptã§ä¸Šæ›¸ãã—ãªã„
  // restoreFilterFromURL();
  
  // æ—¢å­˜ã®ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼ãƒ‘ãƒãƒ«ã‚’ãƒã‚§ãƒƒã‚¯
  let existingPanel = document.getElementById('redmine-issue-summary-filter-panel');
  if (existingPanel) {
    // ã€Œãƒ¬ãƒãƒ¼ãƒˆã€ã®è¦‹å‡ºã—ã‚’æ¢ã™
    const reportHeading = document.querySelector('h2');
    if (reportHeading && reportHeading.textContent.includes('ãƒ¬ãƒãƒ¼ãƒˆ')) {
      // ãƒ¬ãƒãƒ¼ãƒˆè¦‹å‡ºã—ã®ç›´å¾Œã«æŒ¿å…¥
      reportHeading.parentNode.insertBefore(existingPanel, reportHeading.nextSibling);
    } else {
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ãƒ¬ãƒãƒ¼ãƒˆãƒ†ãƒ¼ãƒ–ãƒ«ã®æœ€åˆã®å‰ã«æŒ¿å…¥
      const firstTable = document.querySelector('table');
      if (firstTable) {
        firstTable.parentNode.insertBefore(existingPanel, firstTable);
      }
    }
    
    // ãƒ•ã‚©ãƒ¼ãƒ ã®actionå±æ€§ã‚’ç¢ºå®Ÿã«è¨­å®š
    const filterForm = document.getElementById('redmine-issue-filter-form');
    if (filterForm) {
      const currentPath = window.location.pathname;
      filterForm.action = currentPath;
      
      // ãƒ•ã‚©ãƒ¼ãƒ ã®é€ä¿¡ã‚¤ãƒ™ãƒ³ãƒˆã‚’è¿½åŠ 
      filterForm.addEventListener('submit', function(e) {
        e.preventDefault();
        applyFilter();
      });
    }
    
    // ã‚³ãƒ³ãƒœãƒœãƒƒã‚¯ã‚¹ã®å‹•ä½œã‚’è¨­å®š
    setupSelectBehavior();
  }
});
</script>